'''
Добро пожаловать на встречу со старшим братом Фибоначчи, также известным как Трибоначчи.

Как уже понятно из названия, он работает по принципу Фибоначчи, но для получения следующего числа суммируются последние 3 (а не 2) числа последовательности. И, что ещё хуже, к сожалению, я не смогу услышать, как его произносят люди, для которых итальянский не является родным :(

Итак, если мы хотим начать нашу последовательность Трибоначчи с [1, 1, 1]начальных входных данных (т. н. сигнатуры ), то у нас получится следующая последовательность:

[1, 1 ,1, 3, 5, 9, 17, 31, ...]
Но что, если начать [0, 0, 1]с , [0, 1]а не с , то, [1, 1]по сути, сдвигается обычная последовательность Фибоначчи на одну позицию, и вы можете подумать, что получите ту же последовательность, сдвинутую на две позиции, но это не так, и мы получим:

[0, 0, 1, 1, 2, 4, 7, 13, 24, ...]
Ну, вы, возможно, уже догадались, но для ясности: вам нужно создать функцию Фибоначчи, которая по заданному массиву/списку сигнатур возвращает первые n элементов (включая сигнатуру) заданной таким образом последовательности.

Подпись всегда будет содержать 3 цифры; n всегда будет неотрицательным числом; если n == 0, то вернуть пустой массив (за исключением C, где возвращается NULL) и быть готовым ко всему остальному, что явно не указано ;)
'''
def tribonacci(signature, n):
    if n == 0:
        return []
    i = 0
    tri = []
    while i != n:
        if i <= 2:
            tri.append(signature[i])
            i +=1
        else:
            tri.append(tri[i-1]+tri[i-2]+tri[i-3])
            i +=1
    tribonacci = tri
    return tribonacci


    